<!-- Copilot / AI agent instructions tailored for the xv6-riscv repo -->

# Quick Orientation

This repository is a small teaching operating system (xv6) targeting RISC-V. It contains two main program sets:

- `kernel/` — the kernel sources (C + some assembly). Key concerns: process table, trap handling, virtual memory, device drivers.
- `user/` — simple user-space utilities and tests compiled into standalone user binaries (named with a leading underscore e.g. `_ls`).
- `mkfs/` — small tool to build `fs.img` from `UPROGS` and `README`.

Read these files first for concrete entry points: `Makefile`, `README`, `test-xv6.py`.

# Essential Commands (how developers build / run / test)

- Build kernel: `make kernel/kernel` (or simply `make`).
- Build disk image: `make fs.img` (invokes `mkfs/mkfs`).
- Run in QEMU: `make qemu` (requires a RISC-V toolchain + `qemu-system-riscv64`, QEMU >= 7.2).
- Run QEMU with GDB stub: `make qemu-gdb` and run `gdb` in a separate terminal.
- Run automated tests: `./test-xv6.py <testname>`
  - Quick run of usertests: `./test-xv6.py -q usertests`
  - Crash/recovery tests: `./test-xv6.py crash`

Notes: the Makefile attempts to auto-detect `TOOLPREFIX` (riscv toolchain). Avoid changing compiler flags unless you understand `-fno-builtin-*`, `-ffreestanding`, and `-nostdlib` implications.

# Architecture & Patterns — what to know before editing

- Kernel vs user: There is no libc for the kernel. Kernel code is freestanding, compiled with many `-fno-builtin-*` options.
- User programs are linked with `user/user.ld` and produced as `user/_<name>` binaries. `Makefile`'s `UPROGS` lists the ones embedded into `fs.img`.
- System calls: syscall stubs are generated from `user/usys.pl` -> `user/usys.S`; kernel syscall dispatch is in `kernel/syscall.c` and `kernel/sysproc.c`.
- Process management: `kernel/proc.c` contains the process table, scheduler, `allocproc`, `sched`, `yield`, and related locking conventions (see below for locking idioms).
- Virtual memory: `kernel/vm.c` and `kernel/trampoline.S` implement page tables, trampoline mapping, and user-kernel transitions. TRAMPOLINE and TRAPFRAME are explicitly mapped in `proc_pagetable`.
- Context switches: `kernel/swtch.S`, `kernel/entry.S`, `kernel/trap.c`, and `kernel/trampoline.S` are good examples of low-level state transitions.

# Conventions and idioms specific to this repo

- Locking:
  - Each `struct proc` has its own `p->lock` (initialized in `procinit`). Acquire `p->lock` before modifying that proc's fields.
  - `wait_lock` is used to protect parent/child relationships and must be held around operations that can race with `wait()`/`wakeup()`.
  - `ptable.lock` guards scanning or bulk updates of the process table (`proc[]`).
- Per-CPU data:
  - `cpus[]` and `mycpu()` / `myproc()` helpers — prefer these when writing CPU-local code. `cpuid()` reads thread pointer register.
- Kernel stack allocation: `proc_mapstacks()` allocates per-process kernel stacks at `KSTACK(pid-index)`; do not assume malloc for kernel stacks.
- User memory rules:
  - Kernel must use `copyin`/`copyout` or `either_copyin`/`either_copyout` to safely transfer data between user and kernel memory.
  - Use `proc_pagetable` and `proc_freepagetable` to manage per-process page tables; TRAMPOLINE and TRAPFRAME are mapped specially.
- Binaries & symbols:
  - The link output is `kernel/kernel` and `kernel/kernel.asm` / `kernel/kernel.sym` are generated by the Makefile — use them to inspect disassembly/symbols.

# Testing & Debugging tips (concrete examples)

- To reproduce usertests locally (fast):
  - `make kernel/kernel fs.img` then `./test-xv6.py -q usertests`
- To inspect a running kernel with GDB:
  - `make qemu-gdb` (the Makefile prints `GDBPORT` and creates `.gdbinit`) — then `gdb` in another terminal.
- To reproduce a failing test that interacts with QEMU manually, run `make qemu` and type the test command (e.g. `usertests`) at the xv6 shell.
- Use `test-xv6.py` as the canonical automation harness; it starts QEMU and sends commands to the emulated shell.

# Good-first places to make changes or add features

- `kernel/proc.c` — scheduling, process accounting, and process table locking.
- `kernel/trap.c` and `kernel/vm.c` — careful places for syscall / memory changes.
- `user/` programs — small, self-contained tests are easy to add; add to `UPROGS` in `Makefile` and mkfs will include them in `fs.img`.

# What NOT to do (common pitfalls seen in edits)

- Do not add or rely on host libc behavior in the kernel (kernel is freestanding and uses no stdlib). Avoid changing `-fno-builtin-*` unless necessary.
- Avoid changing object layout or symbol names casually — the Makefile emits `kernel/kernel.asm` and user tests sometimes depend on symbol presence when debugging.

# If you need more context

- Start with `Makefile`, then `kernel/proc.c`, `kernel/trap.c`, `kernel/vm.c`, `kernel/swtch.S`, and `user/usys.pl`.
- If a test fails, use `./test-xv6.py` to reproduce and capture `test-xv6.out`; `test-xv6.py` saves output for debugging.

If anything here is unclear or you'd like examples tailored to a change you're about to make, tell me which file or subsystem and I'll expand these notes with concrete pointers and code snippets.
